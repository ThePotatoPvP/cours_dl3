#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>

#ifndef PIPE_BUF
    #define PIPE_BUF 1 << 8
#endif
// Ex 1:
//
//  $ mkfifo echange
//  $ ./ecrivain.sh &
//  $ cat echange (dans un autre terminal)

// Si on a plusieurs lecteurs chacun lit des bouts, selon à qui est le tour, en pratique le premier arrivé lit tout et vide la file car le texte est court.
// Si on a plusieurs ecrivains les textes se mélangent si trop long, en pratique non.


// EX 2:
//
//  $ for i in {a..z}; do ./ecrivain_basique echange 8192 $i & done
//  $ ./lecteur_basique echange

// Les lettres sont mélangées, le lecteurs compte certaines lettres en bloc de 8192
// et d'autres en deux blocs de 4096, les ecritures se sont pendant la lecture.

int ecrivain(char* pipename, char** messages){
    int fd, pid = getpid();
    if ((fd = open(pipename, O_WRONLY)) < 0){
        perror("open");
        return 1;
    }
    int i = 0;
    while (messages[i] != NULL){
        int len = strlen(messages[i]);
        if (write(fd, &pid, sizeof(int)) < 0 || write(fd, &len, sizeof(int)) < 0 || write(fd, messages[i], len) < 0){
            perror("write");
            return 1;
        }
        i++;
    }
    return 0;
}

int lecteur(char* pipename){
    int fd, pid, len;
    char msg[PIPE_BUF];
    if ((fd = open(pipename, O_RDONLY)) < 0){
        perror("open");
        return 1;
    }
    while(read(fd, &pid, sizeof(int)) && read(fd, &len, sizeof(int)) && read(fd, msg, len)){
        printf("%d a écrit : %s\n", pid, msg);
        for (int i = 0; i < len; msg[i++] = '\0');
    }
    return 0;
}

int main(int argc, char** argv){
    if (argc  < 2){fprintf(stderr, "Merci de donner le nom du tube au moins"); return 1;}
    //return ecrivain(argv[1], argv + 2);
    return lecteur(argv[1]);
}