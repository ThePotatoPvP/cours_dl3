#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>

int smpl(){
    int pipefd[2];
    pipe(pipefd);

    switch (fork()){
        case 0:
            close(pipefd[1]);
            int buf[1];
            read(pipefd[0], buf, sizeof(int));
            printf("Le nombre est: %d\n", buf[0]);
            close(pipefd[0]);
            exit(0);
        default:
            close(pipefd[0]);
            srand(getpid());
            int r = random() % 10;
            printf("Mon nombre est: %d\n", r);

            if (write(pipefd[1], &r, sizeof(int)) < 0){
                perror("write");
                return 1;
            }
            close(pipefd[1]);
            wait(NULL);
            return 0;
    }
}

int ls_tail(){
    int pipefd[2];
    pipe(pipefd);

    switch(fork()){
        case 0:
            close(pipefd[0]);
            dup2(pipefd[1], STDOUT_FILENO);
            char* q[] = {"ls", NULL};
            execvp(q[0], q);

            perror("execvp");
            return 1;

        default:
            close(pipefd[1]);
            wait(NULL);
            dup2(pipefd[0], STDIN_FILENO);
            char* p[] = {"tail", NULL};
            execvp(p[0], p);

            perror("execvp");
            return 1;
    }
}

int ls_head(){
    int pipefd[2];
    pipe(pipefd);

    switch(fork()){
        case 0:
            close(pipefd[0]);
            dup2(pipefd[1], STDOUT_FILENO);
            char* q[] = {"ls", NULL};
            execvp(q[0], q);

            perror("execvp");
            return 1;

        default:
            close(pipefd[1]);
            sleep(5);
            wait(NULL);
            dup2(pipefd[0], STDIN_FILENO);
            char* p[] = {"head", NULL};
            execvp(p[0], p);

            perror("execvp");
            return 1;
    }
}

// IL est préférable que le fils execute le ls, ainsi le père peut aisément lire
// la sortie en une seule fois et on limite les syscalls, le père n'a pas
// de moyen aussi simple de savori si on père a fini.

int synchro(){
    int pipefd[2];
    pipe(pipefd);

    switch(fork()){
        case 0:
            close(pipefd[1]);
            char buf;
            read(pipefd[0], &buf, 1);
            write(STDOUT_FILENO, "Moi aussi !\n", strlen("Moi aussi !\n"));
            exit(3);

        default:
            close(pipefd[0]);
            srand(getpid());
            sleep(random() % 5);
            write(STDOUT_FILENO, "J'ai fini ma sieste !\n", strlen("J'ai fini ma sieste !\n"));

            if (write(pipefd[1], "r", 1) < 0){
                perror("write");
                return 1;
            }

            close(pipefd[1]);
            wait(NULL);
            return 0;
    }
}

int pingpong(){
    int pipe1[2], pipe2[2];
    pipe(pipe1); pipe(pipe2);
    char buf;

    switch(fork()){
        case 0:
            close(pipe1[0]); close(pipe2[1]);
            srand(getpid());

            lito:
            if (read(pipe2[0], &buf, 1) < 0){
                perror("read");
                return 1;
            }

            if (buf == 'p'){
                if (random() % 5){
                    write(STDOUT_FILENO, "ping\n", 5);
                    write(pipe1[1], "p", 1);
                    goto lito;
                } else {
                    write(STDOUT_FILENO, "Dehors, j'ai gagné!\n", strlen("Dehors, j'ai gagné!\n"));
                    write(pipe1[1], "w", 1);
                    exit(3);
                }
            } else {
                write(STDOUT_FILENO, "Bravo... une petite revanche?\n", strlen("Bravo... une petite revanche?\n"));
                exit(3);
            }
        default:
            close(pipe1[1]); close(pipe2[0]);
            srand(getpid());

            write(STDOUT_FILENO, "pong\n", 5);
            write(pipe2[1], "p", 1);

            wito:
            if (read(pipe1[0], &buf, 1) < 0){
                perror("read");
                return 1;
            }

            if (buf == 'p'){
                if (random() % 5){
                    write(STDOUT_FILENO, "pong\n", 5);
                    write(pipe2[1], "p", 1);
                    goto wito;
                } else {
                    write(STDOUT_FILENO, "Dehors, j'ai gagné!\n", strlen("Dehors, j'ai gagné!\n"));
                    write(pipe2[1], "w", 1);
                    wait(NULL);
                    return 0;
                }
            } else {
                write(STDOUT_FILENO, "Bravo... une petite revanche?\n", strlen("Bravo... une petite revanche?\n"));
            }
    }
}

/* Si chacun met le même carcactère pour dire qu'il a joué il faut 2 tubes, sinon
un joueur peut jouer plusieurs fois d'affilée s'il lit en premier le tube. Si chaque
joueur écrit un caractère distincts ça doit pouvoir marcher avec un tube. */

char* utos(unsigned int n){
    int decimals = (n == 0);
    for(int m=n; m > 0; m /= 10){decimals++;}
    // unsigned int to string
    char* res = malloc(sizeof(char)*(decimals+1));
    if (res == NULL){exit(1);}

    int i = decimals;
    for(; n > 0 || i > 0; n /= 10){
        res[--i] = (char)((n % 10)+48);
    }
    res[decimals] = '\0';
    return res;
}

void write_state(int i, int patate){
    char* c = calloc(sizeof(char), 1<<10);
    char* moni = utos(i); char* monp = utos(patate);
    strcat(c, "Je suis le thread n°");
    strcat(c, moni);
    strcat(c, " et la patate vaut ");
    strcat(c, monp);
    strcat(c, "\n");
    free(moni);
    free(monp);
    write(STDOUT_FILENO, c, strlen(c));
    free(c);
}

int main(int argc, char* argv[]){
    //return smpl();
    //return ls_tail();
    //return ls_head();
    //return synchro();
    //return pingpong();
    if (argc < 3){
        printf("NotImplemented\n");
        return 1;
    }
    return patatax(atoi(argv[1]), atoi(argv[2]));
}